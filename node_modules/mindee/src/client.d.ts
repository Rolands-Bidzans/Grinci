/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { Readable } from "stream";
import { Base64Input, BytesInput, InputSource, PathInput, StreamInput, PageOptions, UrlInput, BufferInput } from "./input";
import { Endpoint } from "./http";
import { AsyncPredictResponse, FeedbackResponse, Inference, PredictResponse, StringDict } from "./parsing/common";
/**
 * Options relating to predictions.
 */
export interface PredictOptions {
    /** A custom endpoint. */
    endpoint?: Endpoint;
    /**
     * Whether to include the full text for each page.
     *
     * This performs a full OCR operation on the server and will increase response time.
     */
    allWords?: boolean;
    /**
     * Whether to include cropper results for each page.
     *
     * This performs a cropping operation on the server and will increase response time.
     */
    cropper?: boolean;
    /**
     * If set, remove pages from the document as specified.
     * This is done before sending the file to the server and is useful to avoid page limitations.
     */
    pageOptions?: PageOptions;
}
/**
 * Asynchronous polling parameters.
 */
export interface OptionalAsyncOptions extends PredictOptions {
    initialDelaySec?: number;
    delaySec?: number;
    maxRetries?: number;
    initialTimerOptions?: {
        ref?: boolean;
        signal?: AbortSignal;
    };
    recurringTimerOptions?: {
        ref?: boolean;
        signal?: AbortSignal;
    };
}
export interface AsyncOptions extends PredictOptions {
    initialDelaySec: number;
    delaySec: number;
    maxRetries: number;
    initialTimerOptions?: {
        ref?: boolean;
        signal?: AbortSignal;
    };
    recurringTimerOptions?: {
        ref?: boolean;
        signal?: AbortSignal;
    };
}
export interface ClientOptions {
    /** Your API key for all endpoints. */
    apiKey?: string;
    /** Raise an `Error` on errors. */
    throwOnError?: boolean;
    /** Log debug messages. */
    debug?: boolean;
}
/**
 * Mindee Client class that centralizes most basic operations.
 *
 * @category Client
 */
export declare class Client {
    #private;
    /** Key of the API. */
    protected apiKey: string;
    /**
     * @param {ClientOptions} options options for the initialization of a client.
     */
    constructor({ apiKey, throwOnError, debug }?: ClientOptions);
    /**
     * Send a document to a synchronous endpoint and parse the predictions.
     *
     * @param productClass product class to use for calling the API and parsing the response.
     * @param inputSource file to parse.
     * @param params parameters relating to prediction options.
     * @typeParam T an extension of an `Inference`. Can be omitted as it will be inferred from the `productClass`.
     * @category Synchronous
     * @returns a `Promise` containing parsing results.
     */
    parse<T extends Inference>(productClass: new (httpResponse: StringDict) => T, inputSource: InputSource, params?: PredictOptions): Promise<PredictResponse<T>>;
    /**
     * Send the document to an asynchronous endpoint and return its ID in the queue.
     * @param productClass product class to use for calling  the API and parsing the response.
     * @param inputSource file to parse.
     * @param params parameters relating to prediction options.
     * @category Asynchronous
     * @returns a `Promise` containing the job (queue) corresponding to a document.
     */
    enqueue<T extends Inference>(productClass: new (httpResponse: StringDict) => T, inputSource: InputSource, params?: PredictOptions): Promise<AsyncPredictResponse<T>>;
    /**
     * Polls a queue and returns its status as well as the prediction results if the parsing is done.
     *
     * @param productClass product class to use for calling  the API and parsing the response.
     * @param queueId id of the queue to poll.
     * @param params parameters relating to prediction options.
     * @typeParam T an extension of an `Inference`. Can be omitted as it will be inferred from the `productClass`.
     * @category Asynchronous
     * @returns a `Promise` containing a `Job`, which also contains a `Document` if the
     * parsing is complete.
     */
    parseQueued<T extends Inference>(productClass: new (httpResponse: StringDict) => T, queueId: string, params?: PredictOptions): Promise<AsyncPredictResponse<T>>;
    /**
     * Fetch prediction results from a document already processed.
     *
     * @param productClass product class to use for calling  the API and parsing the response.
     * @param documentId id of the document to fetch.
     * @param params optional parameters.
     * @param params.endpoint Endpoint, only specify if using a custom product.
     * @typeParam T an extension of an `Inference`. Can be omitted as it will be inferred from the `productClass`.
     * @category Synchronous
     * @returns a `Promise` containing parsing results.
     */
    getDocument<T extends Inference>(productClass: new (httpResponse: StringDict) => T, documentId: string, params?: {
        endpoint?: Endpoint;
    }): Promise<PredictResponse<T>>;
    /**
     * Send a feedback for a document.
     *
     * @param productClass product class to use for calling  the API and parsing the response.
     * @param documentId id of the document to send feedback for.
     * @param feedback the feedback to send.
     * @param params optional parameters.
     * @param params.endpoint Endpoint, only specify if using a custom product.
     * @typeParam T an extension of an `Inference`. Can be omitted as it will be inferred from the `productClass`.
     * @category Synchronous
     * @returns a `Promise` containing feedback results.
     */
    sendFeedback<T extends Inference>(productClass: new (httpResponse: StringDict) => T, documentId: string, feedback: StringDict, params?: {
        endpoint?: Endpoint;
    }): Promise<FeedbackResponse>;
    /**
     * Send a document to an asynchronous endpoint and poll the server until the result is sent or
     * until the maximum amount of tries is reached.
     *
     * @param productClass product class to use for calling the API and parsing the response.
     * @param inputSource document to parse.
     * @param asyncParams parameters relating to prediction options.
     *
     * @typeParam T an extension of an `Inference`. Can be omitted as it will be inferred from the `productClass`.
     * @category Synchronous
     * @returns a `Promise` containing parsing results.
     */
    enqueueAndParse<T extends Inference>(productClass: new (httpResponse: StringDict) => T, inputSource: InputSource, asyncParams?: OptionalAsyncOptions): Promise<AsyncPredictResponse<T>>;
    /**
     * Forces boolean coercion on truthy/falsy parameters.
     * @param param input parameter to check.
     * @returns a strict boolean value.
     */
    protected getBooleanParam(param?: boolean): boolean;
    /**
     * Creates a custom endpoint with the given values. Raises an error if the endpoint is invalid.
     * @param endpointName Name of the custom Endpoint.
     * @param accountName Name of the account tied to the Endpoint.
     * @param endpointVersion Version of the custom Endpoint.
     * @typeParam T an extension of an `Inference`. Can be omitted as it will be inferred from the `productClass`.
     *
     * @returns Endpoint a new product endpoint
     */
    createEndpoint(endpointName: string, accountName: string, endpointVersion?: string): Endpoint;
    /**
     * Load an input document from a local path.
     * @param inputPath
     */
    docFromPath(inputPath: string): PathInput;
    /**
     * Load an input document from a base64 encoded string.
     * @param inputString input content, as a string.
     * @param filename file name.
     */
    docFromBase64(inputString: string, filename: string): Base64Input;
    /**
     * Load an input document from a `stream.Readable` object.
     * @param inputStream input content, as a readable stream.
     * @param filename file name.
     */
    docFromStream(inputStream: Readable, filename: string): StreamInput;
    /**
     * Load an input document from a bytes string.
     * @param inputBytes input content, as readable bytes.
     * @param filename file name.
     */
    docFromBytes(inputBytes: string, filename: string): BytesInput;
    /**
     * Load an input document from a URL.
     * @param url input url. Must be HTTPS.
     */
    docFromUrl(url: string): UrlInput;
    /**
     * Load an input document from a Buffer.
     * @param buffer input content, as a buffer.
     * @param filename file name.
     */
    docFromBuffer(buffer: Buffer, filename: string): BufferInput;
}

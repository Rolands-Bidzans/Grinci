"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Endpoint_instances, _Endpoint_cutDocPages, _Endpoint_predictReqPost, _Endpoint_predictAsyncReqPost, _Endpoint_documentQueueReqGet, _Endpoint_documentGetReq, _Endpoint_documentFeedbackPutReq;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Endpoint = void 0;
const url_1 = require("url");
const form_data_1 = __importDefault(require("form-data"));
const base_1 = require("../input/base");
const error_1 = require("./error");
const baseEndpoint_1 = require("./baseEndpoint");
const responseValidation_1 = require("./responseValidation");
/**
 * Endpoint for a product (OTS or Custom).
 */
class Endpoint extends baseEndpoint_1.BaseEndpoint {
    constructor(urlName, owner, version, settings) {
        super(settings);
        _Endpoint_instances.add(this);
        this.owner = owner;
        this.urlName = urlName;
        this.version = version;
        this.urlRoot = `/v1/products/${owner}/${urlName}/v${version}`;
    }
    /**
     * Sends a prediction to the API and parses out the result.
     * Throws an error if the server's response contains one.
     * @param {PredictParams} params parameters relating to prediction options.
     * @category Synchronous
     * @returns a `Promise` containing parsing results.
     */
    async predict(params) {
        await params.inputDoc.init();
        if (params.pageOptions !== undefined) {
            await __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_cutDocPages).call(this, params.inputDoc, params.pageOptions);
        }
        const response = await __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_predictReqPost).call(this, params.inputDoc, params.includeWords, params.cropper);
        if (!(0, responseValidation_1.isValidSyncResponse)(response)) {
            (0, error_1.handleError)(this.urlName, response, response.messageObj?.statusMessage);
        }
        return response;
    }
    /**
     * Enqueues a prediction to the API.
     * Throws an error if the server's response contains one.
     * @param {PredictParams} params parameters relating to prediction options.
     * @category Asynchronous
     * @returns a `Promise` containing queue data.
     */
    async predictAsync(params) {
        await params.inputDoc.init();
        if (params.pageOptions !== undefined) {
            await __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_cutDocPages).call(this, params.inputDoc, params.pageOptions);
        }
        const response = await __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_predictAsyncReqPost).call(this, params.inputDoc, params.includeWords, params.cropper);
        if (!(0, responseValidation_1.isValidAsyncResponse)(response)) {
            (0, error_1.handleError)(this.urlName, response, response.messageObj?.statusMessage);
        }
        return response;
    }
    /**
     * Requests the results of a queued document from the API.
     * Throws an error if the server's response contains one.
     * @param queueId The document's ID in the queue.
     * @category Asynchronous
     * @returns a `Promise` containing the parsed result.
     */
    async getQueuedDocument(queueId) {
        const queueResponse = await __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_documentQueueReqGet).call(this, queueId);
        const queueStatusCode = queueResponse.messageObj.statusCode;
        if (!(0, responseValidation_1.isValidAsyncResponse)(queueResponse)) {
            (0, error_1.handleError)(this.urlName, queueResponse, queueResponse.messageObj?.statusMessage);
        }
        if (queueStatusCode === 302 &&
            queueResponse.messageObj.headers.location !== undefined) {
            const docId = queueResponse.messageObj.headers.location.split("/").pop();
            if (docId !== undefined) {
                return await __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_documentGetReq).call(this, docId);
            }
        }
        return queueResponse;
    }
    /**
     * Send a feedback
     * @param {string} documentId
     */
    async getDocument(documentId) {
        const response = await __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_documentGetReq).call(this, documentId);
        if (!(0, responseValidation_1.isValidAsyncResponse)(response)) {
            (0, error_1.handleError)("document", response, response.messageObj?.statusMessage);
        }
        return response;
    }
    /**
     * Send a feedback
     * @param {string} documentId - ID of the document to send feedback to.
     * @param {StringDict} feedback - Feedback object to send.
     */
    async sendFeedback(documentId, feedback) {
        const response = await __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_documentFeedbackPutReq).call(this, documentId, feedback);
        if (!(0, responseValidation_1.isValidSyncResponse)(response)) {
            (0, error_1.handleError)("feedback", response, response.messageObj?.statusMessage);
        }
        return response;
    }
    /**
     * Send a file to a prediction API.
     * @param input
     * @param predictUrl
     * @param includeWords
     * @param cropper
     */
    sendFileForPrediction(input, predictUrl, includeWords = false, cropper = false) {
        return new Promise((resolve, reject) => {
            const searchParams = new url_1.URLSearchParams();
            if (cropper) {
                searchParams.append("cropper", "true");
            }
            const form = new form_data_1.default();
            if (input instanceof base_1.LocalInputSource && input.fileObject instanceof Buffer) {
                form.append("document", input.fileObject, {
                    filename: input.filename,
                });
            }
            else {
                form.append("document", input.fileObject);
            }
            if (includeWords) {
                form.append("include_mvision", "true");
            }
            const headers = { ...this.settings.baseHeaders, ...form.getHeaders() };
            let path = `${this.urlRoot}/${predictUrl}`;
            if (searchParams.keys.length > 0) {
                path += `?${searchParams}`;
            }
            const options = {
                method: "POST",
                headers: headers,
                hostname: this.settings.hostname,
                path: path,
            };
            const req = this.readResponse(options, resolve, reject);
            form.pipe(req);
            // potential ECONNRESET if we don't end the request.
            req.end();
        });
    }
}
exports.Endpoint = Endpoint;
_Endpoint_instances = new WeakSet(), _Endpoint_cutDocPages = 
/**
 * Cuts a document's pages according to the given options.
 * @param inputDoc input document.
 * @param pageOptions page cutting options.
 */
async function _Endpoint_cutDocPages(inputDoc, pageOptions) {
    if (inputDoc instanceof base_1.LocalInputSource && inputDoc.isPdf()) {
        await inputDoc.cutPdf(pageOptions);
    }
}, _Endpoint_predictReqPost = function _Endpoint_predictReqPost(input, includeWords = false, cropper = false) {
    return this.sendFileForPrediction(input, "predict", includeWords, cropper);
}, _Endpoint_predictAsyncReqPost = function _Endpoint_predictAsyncReqPost(input, includeWords = false, cropper = false) {
    return this.sendFileForPrediction(input, "predict_async", includeWords, cropper);
}, _Endpoint_documentQueueReqGet = function _Endpoint_documentQueueReqGet(queueId) {
    return new Promise((resolve, reject) => {
        const options = {
            method: "GET",
            headers: this.settings.baseHeaders,
            hostname: this.settings.hostname,
            path: `${this.urlRoot}/documents/queue/${queueId}`,
        };
        const req = this.readResponse(options, resolve, reject);
        // potential ECONNRESET if we don't end the request.
        req.end();
    });
}, _Endpoint_documentGetReq = function _Endpoint_documentGetReq(documentId) {
    return new Promise((resolve, reject) => {
        const options = {
            method: "GET",
            headers: this.settings.baseHeaders,
            hostname: this.settings.hostname,
            path: `${this.urlRoot}/documents/${documentId}`,
        };
        const req = this.readResponse(options, resolve, reject);
        // potential ECONNRESET if we don't end the request.
        req.end();
    });
}, _Endpoint_documentFeedbackPutReq = function _Endpoint_documentFeedbackPutReq(documentId, feedback) {
    return new Promise((resolve, reject) => {
        const options = {
            method: "PUT",
            headers: this.settings.baseHeaders,
            hostname: this.settings.hostname,
            path: `/v1/documents/${documentId}/feedback`,
        };
        const req = this.readResponse(options, resolve, reject);
        req.write(JSON.stringify(feedback));
        // potential ECONNRESET if we don't end the request.
        req.end();
    });
};

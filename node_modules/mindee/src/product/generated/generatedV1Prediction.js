"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratedV1Prediction = void 0;
const common_1 = require("../../../src/parsing/common");
const generated_1 = require("../../../src/parsing/generated");
const standard_1 = require("../../../src/parsing/standard");
class GeneratedV1Prediction {
    constructor() {
        this.fields = new Map();
    }
    toString() {
        let outStr = "";
        const pattern = /^(\n*[  ]*)( {2}):/;
        this.fields.forEach((fieldValue, fieldName) => {
            let strValue = "";
            if (fieldValue instanceof generated_1.GeneratedListField &&
                fieldValue.values.length > 0) {
                if (fieldValue.values[0] instanceof generated_1.GeneratedObjectField) {
                    strValue += fieldValue.values[0].toStringLevel(1).replace(pattern, "$1* :");
                }
                else {
                    strValue += fieldValue.values[0].toString().replace(pattern, "$1* :") + "\n";
                }
                for (const subValue of fieldValue.values.slice(1)) {
                    if (subValue instanceof generated_1.GeneratedObjectField) {
                        strValue += subValue.toStringLevel(1).replace(pattern, "$1* :");
                    }
                    else {
                        strValue += ` ${" ".repeat(fieldName.length + 2)}${subValue}\n`;
                    }
                }
                strValue = strValue.trimEnd();
            }
            else {
                strValue = fieldValue.toString();
            }
            outStr += `:${fieldName}: ${strValue}\n`;
        });
        return (0, common_1.cleanOutString)(outStr.trimEnd());
    }
    /**
     * Returns a dictionary of all fields that aren't a collection.
     */
    getSingleField() {
        const singleFields = new Map();
        for (const [fieldName, fieldValue] of Object.entries(this.fields)) {
            if (fieldValue instanceof standard_1.StringField) {
                singleFields.set(fieldName, fieldValue);
            }
        }
        return singleFields;
    }
    /**
     * Returns a dictionary of all array-like fields.
     */
    getArrayFields() {
        const arrayFields = new Map();
        for (const [fieldName, fieldValue] of Object.entries(this.fields)) {
            if (fieldValue instanceof generated_1.GeneratedListField) {
                arrayFields.set(fieldName, fieldValue);
            }
        }
        return arrayFields;
    }
    /**
     * Returns a dictionary of all object-like fields.
     */
    getObjectFields() {
        const objectFields = new Map();
        for (const [fieldName, fieldValue] of Object.entries(this.fields)) {
            if (fieldValue instanceof generated_1.GeneratedObjectField) {
                objectFields.set(fieldName, fieldValue);
            }
        }
        return objectFields;
    }
    /**
     * Lists names of all top-level field keys.
     */
    listFieldNames() {
        return Object.keys(this.fields);
    }
}
exports.GeneratedV1Prediction = GeneratedV1Prediction;
